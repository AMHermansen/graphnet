"""Classification-specific `Model` class(es)."""

from typing import Any, Union, List, Optional

import torch
from torch import Tensor

from graphnet.models.task import Task, IdentityTask


class MulticlassClassificationTask(IdentityTask):
    """Task used for multi-classification."""

    def __init__(
        self,
        nb_outputs: int,
        target_labels: Union[List[str], Any],
        prediction_labels: Optional[List[str]] = None,
        *args: Any,
        **kwargs: Any,
    ):
        """Construct Multi Classification Task module.

        Args:
            nb_outputs: Number of outputs.
            target_labels: Target labels.
            prediction_labels: Labels used for prediction, defaults to labels generated by IdentityTask.
            *args:
            **kwargs:
        """
        super().__init__(nb_outputs, target_labels, *args, **kwargs)
        if prediction_labels is not None:
            self._default_prediction_labels = prediction_labels

        if nb_outputs != len(self._default_prediction_labels):
            self.warning(
                "Specified number of outputs and number of prediction labels don't match. Result saving might get corrupted."
            )

    """General task for classifying any number of classes.

    Requires the same number of input features as the number of classes being
    predicted. Returns the untransformed latent features, which are interpreted
    as the logits for each class being classified.
    """


class BinaryClassificationTask(Task):
    """Performs binary classification."""

    # Requires one feature, logit for being signal class.
    nb_inputs = 1
    default_target_labels = ["target"]
    default_prediction_labels = ["target_pred"]

    def _forward(self, x: Tensor) -> Tensor:
        # transform probability of being muon
        return torch.sigmoid(x)


class BinaryClassificationTaskLogits(Task):
    """Performs binary classification form logits."""

    # Requires one feature, logit for being signal class.
    nb_inputs = 1
    default_target_labels = ["target"]
    default_prediction_labels = ["target_pred"]

    def _forward(self, x: Tensor) -> Tensor:
        return x
